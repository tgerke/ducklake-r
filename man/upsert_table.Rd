% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/upsert_table.R
\name{upsert_table}
\alias{upsert_table}
\title{Upsert data from a dplyr query into a DuckLake table}
\usage{
upsert_table(.data, table_name = NULL, by, .quiet = TRUE)
}
\arguments{
\item{.data}{A dplyr query object (tbl_lazy) with the source data}

\item{table_name}{The target table name. If not provided, will be extracted from the table attribute (set by get_ducklake_table())}

\item{by}{Character vector of column names to match on (merge keys)}

\item{.quiet}{Logical, whether to suppress debug output (default TRUE)}
}
\value{
The result from executing the MERGE statement
}
\description{
Performs a MERGE operation: updates existing rows and inserts new ones based on matching keys.
This is the pipeline-based version of rows_upsert() for use with dplyr queries.
}
\details{
This is the pipeline-based approach to upserts, ideal when transforming data with dplyr verbs.
For upserting data.frames directly, see \code{\link[=rows_upsert]{rows_upsert()}}.

This function generates a DuckDB INSERT ... ON CONFLICT statement (which provides MERGE/UPSERT functionality).
Rows are matched based on the columns specified in \code{by}. If a match is found, the row is updated;
if not, a new row is inserted.

\strong{Note:} This function requires that the table has a PRIMARY KEY or UNIQUE constraint on the columns
specified in \code{by}. If your table doesn't have these constraints, use \code{\link[=rows_upsert]{rows_upsert()}} instead.
}
\examples{
\dontrun{
# Upsert data from a computed query
get_ducklake_table("staging_table") |>
  mutate(processed = TRUE) |>
  upsert_table("target_table", by = "id")

# Upsert with table name inferred
get_ducklake_table("my_table") |>
  filter(status == "active") |>
  mutate(last_updated = Sys.time()) |>
  upsert_table(by = c("id", "version"))
}
}
\seealso{
\code{\link[=rows_upsert]{rows_upsert()}} for the data.frame approach to upserts
}
