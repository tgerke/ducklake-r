---
title: "Modifying Tables with Version Control"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Modifying Tables with Version Control}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
knitr::opts_knit$set(root.dir = tempdir())
```

This vignette demonstrates how to modify tables in a DuckLake while maintaining complete version control and audit trails. 
This is essential for reproducible workflows.

```{r setup}
library(ducklake)
library(dplyr)

# Setup for examples
install_ducklake()
attach_ducklake("my_ducklake", lake_path = tempdir())

# Load a sample dataset
with_transaction(
  create_table(mtcars, "cars"),
  author = "Data Engineer",
  commit_message = "Initial car data load"
)
```

## Best Practices for Table Modifications

For data workflows requiring audit trails and reproducibility, ducklake offers versioning functions that preserve complete history of all changes.

### Recommended: `replace_table()` with transactions

**Use `replace_table()` wrapped in `with_transaction()` for all table modifications:**

```r
# Modify and replace - creates versioned snapshot
with_transaction(
  get_ducklake_table("my_table") |>
    filter(status == "active") |>
    mutate(processed = TRUE) |>
    replace_table("my_table"),
  author = "Your Name",
  commit_message = "Mark active records as processed"
)
```

**Why this approach?**

- **Creates snapshots** - Every change is versioned and can be time-traveled back to
- **Maintains audit trail** - Complete history of what changed, when, and by whom
- **Enables reproducibility** - Recreate analyses from any point in time
- **Supports regulatory compliance** - Meets 21 CFR Part 11 requirements for GxP work
- **Works with dplyr** - Natural pipeline syntax with `filter()`, `mutate()`, `select()`, etc.

### Alternative: `rows_*` functions (⚠️ No versioning)

The `rows_*` functions provide dplyr-style operations but **do not create snapshots or audit trails**:

```r
# These modify tables in-place WITHOUT creating snapshots
rows_update(get_ducklake_table("my_table"), updates, by = "id")
rows_insert(get_ducklake_table("my_table"), new_data, by = "id")
rows_delete(get_ducklake_table("my_table"), to_delete, by = "id")
```

**⚠️ Use only when:**
- Working in non-GxP environments where audit trails are not required
- You explicitly want to avoid creating new versions

**For most workflows, especially those requiring reproducibility or regulatory compliance, prefer `replace_table()` to maintain complete data lineage.**

## Examples

### Updating specific rows with `replace_table()`

```{r update-rows}
# Update mpg values for specific cars (4-cylinder cars get a 5% efficiency boost)
with_transaction(
  get_ducklake_table("cars") |>
    mutate(
      mpg = if_else(cyl == 4, mpg * 1.05, mpg)
    ) |>
    replace_table("cars"),
  author = "Data Engineer",
  commit_message = "Update MPG for 4-cylinder vehicles"
)

# Check version history - should show the new snapshot
list_table_snapshots("cars")
```

### Adding derived columns

```{r add-columns}
# Add new derived columns to existing table
with_transaction(
  get_ducklake_table("cars") |>
    mutate(
      hp_per_cyl = hp / cyl,
      # Add a new flag column
      high_performance = if_else(hp > 200, "Y", "N")
    ) |>
    replace_table("cars"),
  author = "Data Engineer",
  commit_message = "Add HP per cylinder and performance flag"
)

# Verify new columns exist
get_ducklake_table("cars") |>
  filter(hp > 200) |>
  select(hp, cyl, hp_per_cyl, high_performance)
```

### Preview SQL before execution

```{r preview-sql}
# View the SQL that will be executed before committing
get_ducklake_table("cars") |>
  mutate(
    hp_per_cyl = hp / cyl,
    high_performance = if_else(hp > 200, "Y", "N")
  ) |>
  show_ducklake_query()
```

### Filtering rows with `replace_table()`

```{r filter}
# Keep only specific rows - creates a versioned snapshot
with_transaction(
  get_ducklake_table("cars") |>
    filter(cyl == 8) |>
    replace_table("cars"),
  author = "Data Engineer",
  commit_message = "Filter to V8 engines only"
)

# Show the filtered table
get_ducklake_table("cars")

# View version history - old versions still accessible via time travel
list_table_snapshots("cars")
```

### Time Travel: Accessing Previous Versions

```{r time-travel}
# Get the current version
current <- get_ducklake_table("cars") |> collect()

# List all snapshots to see available versions
snapshots <- list_table_snapshots("cars")
snapshots

# Access a specific previous version by snapshot_id
original_version <- get_ducklake_table_version(
  "cars", 
  snapshots$snapshot_id[1]
) |> collect()

# Compare: how many rows changed?
nrow(current)
nrow(original_version)
```

```{r cleanup, include=FALSE}
detach_ducklake("my_ducklake")
```
