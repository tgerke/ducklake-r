---
title: "Time Travel Queries"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Time Travel Queries}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
knitr::opts_knit$set(root.dir = tempdir())
```

```{r setup, message=FALSE}
library(ducklake)
library(dplyr)
```

## Introduction

DuckLake's time travel capabilities provide a powerful audit trail for your data, enabling you to:

- View data as it existed at any specific point in time
- Query specific versions of your tables
- Restore tables to previous states
- Track the complete history of changes
- Meet regulatory and compliance requirements

This functionality is especially valuable in domains where data provenance and reproducibility are critical, such as clinical trials, financial reporting, and scientific research.

## Setting Up the Data Lake

We'll start by creating a new DuckLake and loading the mtcars dataset. We'll then make several modifications to demonstrate time travel functionality.

```{r create-datalake}
# Install the ducklake extension (required once per system)
install_ducklake()

# Create or attach to a data lake
attach_ducklake(
  ducklake_name = "time_travel_demo",
  lake_path = tempdir()
)

# Create initial table with the mtcars dataset
with_transaction(
  create_table(mtcars, "cars"),
  author = "Data Engineer",
  commit_message = "Initial load of mtcars dataset"
)

# Verify the table was created
get_ducklake_table("cars") |>
  select(mpg, cyl, hp, wt) |>
  head()
```

## Making Changes Over Time

Let's make several changes to our data to create a version history we can explore.

### Version 1: Initial data

We already have our initial dataset. Let's check the current state:

```{r version1}
get_ducklake_table("cars") |>
  summarise(
    n_cars = n(),
    avg_mpg = mean(mpg, na.rm = TRUE),
    avg_hp = mean(hp, na.rm = TRUE)
  )
```

### Version 2: Update fuel efficiency data

Suppose we discover that fuel efficiency measurements need to be adjusted for some vehicles:

```{r version2}
# Update mpg for high-performance cars (5% reduction)
with_transaction(
  get_ducklake_table("cars") |>
    mutate(mpg = if_else(hp > 200, mpg * 0.95, mpg)) |>
    replace_table("cars"),
  author = "Data Analyst",
  commit_message = "Adjust MPG for high-performance vehicles"
)

# Check the updated averages
get_ducklake_table("cars") |>
  summarise(
    n_cars = n(),
    avg_mpg = mean(mpg, na.rm = TRUE),
    avg_hp = mean(hp, na.rm = TRUE)
  )
```

### Version 3: Add efficiency classification

Let's add a new categorical variable to classify cars by fuel efficiency:

```{r version3}
with_transaction(
  get_ducklake_table("cars") |>
    mutate(
      efficiency_class = case_when(
        mpg >= 25 ~ "High",
        mpg >= 20 ~ "Medium",
        TRUE ~ "Low"
      )
    ) |>
    replace_table("cars"),
  author = "Data Analyst",
  commit_message = "Add efficiency classification"
)

# View the new classification
get_ducklake_table("cars") |>
  count(efficiency_class) |>
  arrange(desc(n))
```

### Version 4: Correct an error

Suppose we realize the efficiency classification thresholds were wrong and need to be corrected:

```{r version4}
with_transaction(
  get_ducklake_table("cars") |>
    mutate(
      efficiency_class = case_when(
        mpg >= 30 ~ "High",
        mpg >= 20 ~ "Medium",
        TRUE ~ "Low"
      )
    ) |>
    replace_table("cars"),
  author = "Senior Analyst",
  commit_message = "Correct efficiency classification thresholds"
)

# View the corrected classification
get_ducklake_table("cars") |>
  count(efficiency_class) |>
  arrange(desc(n))
```

## Exploring Version History

Now that we have a history of changes, let's explore the time travel functionality.

### List all snapshots

```{r list-snapshots}
# View all available versions of the table
snapshots <- list_table_snapshots("cars")
snapshots
```

### Query a specific version

Let's look at version 2, before we added the efficiency classification:

```{r query-version2}
# Get version 2 (after MPG adjustment, before classification)
get_ducklake_table_version("cars", version = 2) |>
  select(mpg, cyl, hp, wt) |>
  head()

# Notice: no efficiency_class column yet
```

Compare this with version 3, which has the classification:

```{r query-version3}
# Get version 3 (with initial classification)
get_ducklake_table_version("cars", version = 3) |>
  select(mpg, efficiency_class) |>
  count(efficiency_class)
```

### Query data as of a specific timestamp

We can also query data as it existed at any point in time:

```{r timestamp-query}
# Get the timestamp from version 2
version2_timestamp <- snapshots |>
  filter(schema_version == 2) |>
  pull(snapshot_time)

# Query data as it existed at that time
get_ducklake_table_asof("cars", version2_timestamp) |>
  summarise(
    avg_mpg = mean(mpg, na.rm = TRUE)
  )
```

## Comparing Versions

One powerful use case is comparing different versions to understand what changed:

```{r compare-versions}
# Get MPG values from version 1 (original) and version 2 (after adjustment)
original <- get_ducklake_table_version("cars", version = 1) |>
  select(mpg) |>
  collect() |>
  mutate(version = "Original")

adjusted <- get_ducklake_table_version("cars", version = 2) |>
  select(mpg) |>
  collect() |>
  mutate(version = "Adjusted")

# Combine and compare
bind_rows(original, adjusted) |>
  group_by(version) |>
  summarise(
    avg_mpg = mean(mpg, na.rm = TRUE),
    min_mpg = min(mpg),
    max_mpg = max(mpg)
  )
```

## Restoring Previous Versions

If we need to undo changes, we can restore a table to a previous version by reading that version and replacing the current table:

```{r restore-demo}
# Let's say we want to go back to version 2 (before adding classifications)
# We restore by reading version 2 and replacing the current table
with_transaction(
  get_ducklake_table_version("cars", version = 2) |>
    replace_table("cars"),
  author = "Senior Analyst", 
  commit_message = "Restore to version 2 (before efficiency classification)"
)

# Verify the restoration - efficiency_class column should be gone
get_ducklake_table("cars") |> colnames()
```

After restoring, we can see that the efficiency_class column is no longer present. A new snapshot is created for the restoration:

```{r after-restore}
list_table_snapshots("cars")
```

## Use Cases for Time Travel

Time travel functionality is particularly valuable for:

1. **Regulatory Compliance**: Maintain complete audit trails for datasets used in regulatory submissions (e.g., clinical trials, financial reporting)
2. **Reproducibility**: Recreate analyses exactly as they were run at specific points in time
3. **Data Recovery**: Restore accidentally modified or deleted data
4. **Change Tracking**: Understand when and how data quality issues were introduced
5. **Reporting**: Generate historical reports using data as it existed at specific time points
6. **Collaboration**: Allow team members to reference specific versions of shared datasets
7. **Debugging**: Identify when unexpected changes occurred in your data pipeline

## Metadata and Audit Information

Each snapshot includes metadata about when it was created and what changes were made. The `list_table_snapshots()` function provides a complete audit trail:

```{r metadata}
# Get detailed snapshot history with all metadata
snapshot_history <- list_table_snapshots("cars")
snapshot_history |>
  select(snapshot_id, snapshot_time, author, commit_message)
```

This complete audit trail ensures that you can always answer questions like:

- What changes were made?
- When were they made?
- What version is the table at?
- What was the data before this change?

You can also access metadata about all tables in the DuckLake:

```{r all-metadata}
# View metadata for all tables
all_snapshots <- list_table_snapshots()
all_snapshots |>
  select(snapshot_id, snapshot_time, changes) |>
  head(10)
```
